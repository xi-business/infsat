open Timing
open Utilities

let report_usage () =
  print_string @@ "Usage: \n" ^
                  "infsat <option>* <filename> \n\n" ^
                  " -d\n" ^
                  "  debug mode\n"

let program_info = "InfSat 0.1: Saturation-based finiteness checker for higher-order " ^
                   "recursion schemes"

let options = [
  ("-q", Arg.Set Flags.quiet, "Enables quiet mode");
  ("-f", Arg.Set Flags.force_unsafe, "Force check even if terms unsafe");
  ("-v", Arg.Set Flags.verbose_main, "Enables basic verbosity");
  ("-vv", Arg.Set Flags.verbose_all, "Enables full verbosity");
  ("-vprep", Arg.Set Flags.verbose_preprocessing, "Enables verbose parsing and preprocessing");
  ("-vproof", Arg.Set Flags.verbose_proofs, "Enables verbose proofs");
  ("-vtype", Arg.Set Flags.verbose_typing, "Enables verbose typing results");
  ("-vsat", Arg.Set Flags.verbose_queues, "Enables verbose saturation tasks");
  ("-vprof", Arg.Set Flags.verbose_profiling, "Enables verbose profiling");
  ("-maxiters", Arg.Set_int Flags.maxiters,
   "Maximum number of saturation iterations before giving up");
  ("-tf", Arg.Symbol (
      ["full"; "shortened"; "short"],
      fun f -> Flags.type_format := f
    ),
   "Format in which types will be printed. \"full\" for " ^
   "(pr, (np, (pr, o) -> o) -> (np, o) -> o), \"shortened\" for " ^
   "(pr, (np, pr -> o) -> np -> o), or \"short\" for (pr -> np) -> np -> pr. " ^
   "Default is \"full\".");
]

(** Parses a file to HORS prerules and automata definition. *)
let parse_file filename =
  let in_strm = 
    try
      open_in filename 
    with
      Sys_error _ ->
      begin
        print_string @@ "Cannot open file: " ^ filename ^ "\n";
        exit (-1)
      end
  in
  print_string @@ "Analyzing " ^ filename ^ ".\n";
  flush stdout;
  let lexbuf = Lexing.from_channel in_strm in
  let result =
    try
      InfSatParser.main InfSatLexer.token lexbuf
    with 
    | Failure _ -> exit (-1) (* exception raised by the lexical analyer *)
    | Parsing.Parse_error ->
      begin
        print_string "Parse error\n";
        exit (-1)
      end
  in
  let _ = 
    try
      close_in in_strm
    with
    | Sys_error _ ->
      print_string @@ "Cannot close file " ^ filename ^ "\n";
      exit(-1)
  in
    result

(** Parses stdin to HORS prerules and automata transitions. *)
let parse_stdin () =
  print_string "reading standard input ...\n";
  let in_strm = stdin in
  let lexbuf = Lexing.from_channel in_strm in
  let result =
    try
      InfSatParser.main InfSatLexer.token lexbuf
    with 
    | Failure _ -> exit (-1) (* exception raised by the lexical analyer *)
    | Parsing.Parse_error -> (print_string "Parse error\n";exit(-1)) 
  in
    result

let string_of_input (prerules, tr) =
  Syntax.string_of_prerules prerules ^ "\n" ^ Syntax.string_of_preterminals tr

(** Main part of InfSat. Takes parsed input, returns whether the paths generated by HORS contain
    uniformly bounded number of counted letters. *)
let report_finiteness input : Saturation.infsat_result =
  let grammar = time "conversion" (fun () -> Conversion.prerules2gram input) in
  time "eta-expansion" (fun () -> EtaExpansion.eta_expand grammar);
  let hgrammar = time "head conversion" (fun () -> new HGrammar.hgrammar grammar) in
  let safety_error =
    if !Flags.force_unsafe then
      begin
        if not !Flags.quiet then
          print_string "Skipping term safety check.\n";
        None
      end
    else
      Safety.check_safety hgrammar
  in
  match safety_error with
  | None ->
    let cfa = time "0CFA" (fun () ->
        let cfa = new Cfa.cfa hgrammar in
        cfa#expand;
        cfa#compute_dependencies;
        cfa)
    in
    time "saturation" (fun () ->
        let saturation = new Saturation.saturation hgrammar cfa in
        saturation#saturate
      )
  | Some error ->
    if not !Flags.quiet then
      print_string @@ "Aborting computations, because one of the terms is not safe:\n" ^
                      error ^ "\n\n" ^
                      "If you wish to ignore the safety check, use -f option.\n";
    Saturation.Unknown

(** Parses given file or stdin and returns whether the HORS is finite. *)
let parse_and_report_finiteness (filename : string option) : Saturation.infsat_result =
  let input = time "parsing" (fun () ->
      try
        match filename with
        | Some f -> parse_file f
        | None -> parse_stdin ()
      with
      | InfSatLexer.LexError s -> failwith @@ "Lexer error: "^s
    )
  in
  print_verbose !Flags.verbose_preprocessing @@ lazy (
    "Input:\n\n" ^ string_of_input input
  );
  report_finiteness input
  
let main () : unit =
  program_info |> Arg.parse options (fun filenames ->
      Flags.propagate_flags ();
      let filename = match filenames with
        | "" -> None
        | f -> Some f
      in
      let start_t = Sys.time () in
      let res = parse_and_report_finiteness filename in
      let end_t = Sys.time () in
      report_timings start_t end_t;
      (* return value indicates finiteness only when return flag is on *)
      if res = Finite || res = Infinite && not !Flags.quiet then
        exit 0
      else
        exit 1
    )
